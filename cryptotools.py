# Author: Janna Harding
# File:   cryptotools.py
# Usage:  this functions as a library, use with the import statement in python
# Desc:   this program contains useful functions, variables and constants
#           for caesar-based ciphers. Used for encrypting and decrypting.
#

import string
from collections import deque

# constants for assisting with list indexing and char representation
ENGLISH_LETTERS   = 26
LOWERCASE_A_ASCII = 97

# define some common characters that should be ignored
special = [".", "?", "'", "!", ":", ";", " ", ",", "â€™", "\n", 
           "/", "(", ")", "-", "[", "]"]
numbers = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]

# a list for storing the relative frequency of english characters
# list items are ASCII values, sorted from most to least common
englishFreq = [4, 19, 0, 14, 8, 13, 18, 17, 7, 3, 11, 20, 2,
               12, 5, 24, 22, 6, 15, 1, 21, 10, 23, 16, 9, 25]




# Function: caesar(string, integer)
# Desc:     this function returns a caesar-encrypted version of the input string
#           inspiration: https://stackoverflow.com/a/8895517/9622074
#           stackoverflow was referenced to arrive at a more pythonic solution;
#           an entirely self-composed solution can be found in code/etc/
#
def caesar(data, shift):
  alphabet = string.ascii_lowercase
  shifted_alphabet = alphabet[shift:] + alphabet[:shift]
  shiftTable = str.maketrans(alphabet, shifted_alphabet)
  return data.translate(shiftTable)




# Function: getShift(string)
# Desc:     this function analyzes a sample of text and determines the shift 
#           value based on 26 passes of a frequency analysis function
#
def getShift(data):
  # define some lists for storing character occurance data
  counts = [0] * ENGLISH_LETTERS   # holds how many of each letter
  shifts = [0] * ENGLISH_LETTERS   # stores shift values based on freq

  # count occurences of individual characters
  totalChars = 0
  for char in data:
    if char not in special and char not in numbers:
      letter = ord(char) - LOWERCASE_A_ASCII
      counts[letter] += 1
      totalChars += 1

  # perform analysis
  for i in range(ENGLISH_LETTERS):
    largest = 0
    for index, char in enumerate(counts):
      if char > counts[largest]: largest = index

    # compares largest char frequency in data to which character has
    # that frequency relative to others in english to determine shift
    currShift = largest - englishFreq[i]
    
    # prevent shifting upward; we only want downward shifting
    if currShift < 0:
      currShift += ENGLISH_LETTERS

    shifts[i] = currShift
    counts[largest] = 0

  # gets most frequent shift value calculated
  # this should be the actual shift for the cipher
  shift = max(set(shifts), key=shifts.count)
  return shift




# Function: chunk(string, integer)
# Desc:    calling this function returns a list of n strings representing chunks
#          of the data string, where the 0th char is placed into subsect[0],
#          the 1st char is placed into subsect[1], etc. up until subsect[n],
#          where the process loops and subsect[n+1] is placed into subsect[0]
#          
#          in the event that punctuation exists in the data text, a deque of
#          tuples that consist of the index of the punctuation and its char will
#          be returned as well. this can be used to reconstruct the chunks while
#          preserving the exact formatting of punctuation
#
def chunk(data, n):
  subsect = [""] * n        # holds divided sections of source text
  punct   = deque()         # a deque to hold punctuation positional data
  count   = 0               # holds which chunk next char is to be assigned

  for i in range(len(data)):
    if data[i] not in special and data[i] not in numbers:
      subsect[count] += data[i]
      count += 1
      if count >= n:
        count = 0
    else:
      punct.append( tuple((i, data[i])) )

  return subsect, punct




# Function: unchunk(chunk list, punctuation deque)
# Desc:     this function accepts a list of chunks and a deque of punctuation
#           tuples that were generated by chunk() and reconstructs them into
#           the same format as the data had originally, then returns that data
#
def unchunk(subsect, punct):
  # rebuild full decrypted string
  count  = 0   # which char in PSWD corresponds to current char
  index  = 0   # num of iterations PSWD encryption loop has been through
  result = ""  # string to use for rebuilding encrypted input string
  length = 0   # will hold how long the string to rebuild is

  # determine string length
  for string in subsect:
    length += len(string)
  for item in punct:
    length += 1

  # combine datasets into a single string
  while len(result) < length:
    if len(punct) and punct[0][0] == len(result):
      result += punct.popleft()[1]
    else: 
      result += subsect[count][index]
      count  += 1
      if count >= len(subsect):
        index  += 1
        count   = 0

  return result




# Function: findPswdLen(string)
# Desc:     this function accepts a data string and then analyzes it to return
#           the length of a password that was used to encrypt a vigenere cipher
#
#           this method of determining the password length is detailed here:
#           https://www.dcode.fr/vigenere-cipher      (near the bottom)
#
#           by partitioning the ciphertext into a number of sections, the IC
#           for each partition will represent how similar these silces are
#           to standard english text. the caesar cipher has an IC that resembles
#           english text, which means that the number of partitions that yields 
#           the highest IC resembles a caesar cipher the most, meaning that
#           number of partitions is most likely the password length
#
def findPswdLen(data):
  ICdict = {}

  # test password lengths from 6 to 100
  for i in range(5, 99):
    # divide given data into as many sections as the current pswd length guess
    subsect, punct = chunk(data, i)

    # count occurences of individual characters within subsections
    ICavg = 0
    for string in subsect:
      counts = [0] * 26
      totalChars = 0

      for char in string:
        letter = ord(char) - 97
        counts[letter] += 1
        totalChars += 1

      # calculate IC for each subsection
      IC = 0
      for letter in counts:
        IC += (letter * (letter - 1))
      IC /= totalChars * (totalChars - 1)

      # average IC for each subsection, that is the IC for this length guess
      ICavg += IC
    ICavg /= len(subsect)

    # create dictionary entry where the IC is the key
    # and the corresponding letter index is the value
    # if the ICavg for this section is 0.06, then it resembles a caesar cipher
    if ICavg >= 0.06: return i
    ICdict[ICavg] = i

  # determine the largest IC value, return its corresponding index
  # the largest IC value's index now indicates the password length
  maxIC = max(ICdict)
  return ICdict[maxIC]